[
  {
    "depth": 2,
    "value": "The Problem with Large Data",
    "id": "the-problem-with-large-data"
  },
  {
    "depth": 2,
    "value": "Why chunking?",
    "id": "why-chunking"
  },
  {
    "depth": 2,
    "value": "The Two Fundamental Models of Streaming",
    "id": "the-two-fundamental-models-of-streaming"
  },
  {
    "depth": 2,
    "value": "Push Architecture",
    "id": "push-architecture"
  },
  {
    "depth": 2,
    "value": "Push Model's Advantages and Limitations",
    "id": "push-models-advantages-and-limitations"
  },
  {
    "depth": 2,
    "value": "Pull Architecture",
    "id": "pull-architecture"
  },
  {
    "depth": 2,
    "value": "Generators and Iterable Protocol",
    "id": "generators-and-iterable-protocol"
  },
  {
    "depth": 2,
    "value": "Async Iterators and for await...of",
    "id": "async-iterators-and-for-awaitof"
  },
  {
    "depth": 2,
    "value": "Pull Model's Advantages and Limitations",
    "id": "pull-models-advantages-and-limitations"
  },
  {
    "depth": 2,
    "value": "Node.js Streams's Hybrid Approach",
    "id": "nodejs-streamss-hybrid-approach"
  },
  {
    "depth": 2,
    "value": "Let's go back... in time",
    "id": "lets-go-back-in-time"
  },
  {
    "depth": 2,
    "value": "The Four Stream Types",
    "id": "the-four-stream-types"
  },
  {
    "depth": 2,
    "value": "Conceptualizing Data Flow",
    "id": "conceptualizing-data-flow"
  },
  {
    "depth": 2,
    "value": "When to Use Streams",
    "id": "when-to-use-streams"
  },
  {
    "depth": 2,
    "value": "Common Use Cases",
    "id": "common-use-cases"
  },
  {
    "depth": 2,
    "value": "Setting the Stage",
    "id": "setting-the-stage"
  }
]